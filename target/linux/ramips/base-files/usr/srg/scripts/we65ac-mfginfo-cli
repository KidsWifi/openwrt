#!/bin/sh
###############################################################################
#               _____                      _  ______ _____                    #
#              /  ___|                    | | | ___ \  __ \                   #
#              \ `--. _ __ ___   __ _ _ __| |_| |_/ / |  \/                   #
#               `--. \ '_ ` _ \ / _` | '__| __|    /| | __                    #
#              /\__/ / | | | | | (_| | |  | |_| |\ \| |_\ \                   #
#              \____/|_| |_| |_|\__,_|_|   \__\_| \_|\____/ Inc.              #
#                                                                             #
###############################################################################
#                                                                             #
#                       copyright 2016 by SmartRG, Inc.                       #
#                              Santa Barbara, CA                              #
#                                                                             #
###############################################################################
#                                                                             #
# Author: Chad Monroe                                                         #
#                                                                             #
# Purpose: Shell for telnet to call during initial device serialization       #
#                                                                             #
###############################################################################
. /lib/ramips.sh


do_exit()
{
	# Restore terminal settings to whatever they were
	stty ${STTY_CFG}

	# Notify user we are closing down
	printf "\nSerialization process finished, disconnecting.. \n\n"
	sleep 1

	exit $1
}


sig_handler() 
{
	# do any cleanup and bail
	printf "\n\ncaught signal, exiting..\n"

	do_exit 1
}


get_hw_info()
{
	if [ -f "/tmp/sysinfo/model" ]; then
		MODEL=$(cat /tmp/sysinfo/model 2>>/dev/null)
	fi

	if [ -n "$MODEL" ]; then
		PRODUCT="$MODEL"
	else
		PRODUCT=$(ramips_board_name)
	fi
}


get_factory_partition()
{
	FACTORY_PART=$(cat /proc/mtd | grep "${FACTORY_PART_NAME}" | cut -d: -f1)

	if [ -z "$FACTORY_PART" ]; then
		printf "ERROR: no MTD device for factory partition found!"

		do_exit 1
	else
		FACTORY_PART=$(printf "/dev/${FACTORY_PART}")
	fi

	printf "Factory partition ${FACTORY_PART_NAME} found at ${FACTORY_PART}\n\n"
}


get_mfg_partition()
{
	MFG_PART=$(cat /proc/mtd | grep "${MFG_PART_NAME}" | cut -d: -f1)

	if [ -z "$MFG_PART" ]; then
		printf "ERROR: no MTD device for manufacturing partition found!"

		do_exit 1
	else
		MFG_PART=$(printf "/dev/${MFG_PART}")
	fi

	printf "Manufacturing partition ${MFG_PART_NAME} found at ${MFG_PART}\n\n"
}


mac_fixup()
{
	SPLIT=${TMP_MAC:0:2}
	for i in 2 4 6 8 10; do
		SPLIT=${SPLIT}:${TMP_MAC:${i}:2}
	done

	TMP_MAC=$(echo $SPLIT)
}


verify_mac()
{
	local search

	# trim and capitalize                                 
	TMP_MAC=$(printf ${TMP_MAC} | awk '{print toupper($0)}')

	# check for invalid characters (not : or hex)
	TMP_MAC=$(printf "$TMP_MAC" | grep -E "^([a-fA-F0-9:]+)$")
	if [ ${#TMP_MAC} -le 0 ]; then
		return 1
	fi

	# if entered without seperators (e.g. via barcode
	# reader) then add in seperators if value is valid
	search=$(printf "$TMP_MAC" | grep ':')
	if [ -z "$search" ]; then
		if [ ${#TMP_MAC} -eq 12 ]; then
			mac_fixup
		else
			printf "\ERROR: no seperators found in MAC and size incorrect\n"
			return 1
		fi
	fi

	# make sure it's formatted as we are expecting and 17 chars long
	TMP_MAC=$(printf "$TMP_MAC" | grep -E "^([0-9A-Fa-f]{2})((:[0-9A-Fa-f]{2}){5})$")
	if [ ${#TMP_MAC} -ne 17 ]; then                     
		return 1                              
	fi  

	# got a good MAC
	return 0
}


verify_serial()
{
	# trim and capitalize                                    
	TMP_SN=$(printf ${TMP_SN} | awk '{print toupper($0)}')

	# split SN into model
	TMP_MODEL=$(printf "$TMP_SN" | cut -d- -f1)
	if [ ${#TMP_MODEL} -le 0 ]; then
		return 1
	fi

	# check for valid data and length
	TMP_MODEL=$(printf "$TMP_MODEL" | grep -E "^([a-zA-Z0-9]{10})$")
	if [ ${#TMP_MODEL} -ne 10 ]; then
		return 1
	fi

	# split SN into serial
	TMP_SERIAL=$(printf "$TMP_SN" | cut -d- -f2)
	if [ ${#TMP_SERIAL} -le 0 ]; then
		return 1
	fi

	# check for valid data and length
	TMP_SERIAL=$(printf "$TMP_SERIAL" | grep -E "^([0-9]{7})$")
	if [ ${#TMP_SERIAL} -ne 7 ]; then
		return 1
	fi

	# got a good model + S/N
	return 0
}


verify_hw_rev()
{
	# trim and capitalize                                    
	TMP_HWREV=$(printf ${TMP_HWREV} | awk '{print toupper($0)}')

	# check for valid data and length
	TMP_HWREV=$(printf "$TMP_HWREV" | grep -E "^([a-zA-Z0-9]{2})$")
	if [ ${#TMP_HWREV} -ne 2 ]; then
		return 1
	fi


	# not much else we can do here.. looks good
	return 0
}


verify_hw_engnum()
{
	# trim string
	TMP_ENGNUM=$(printf ${TMP_ENGNUM})

	# check for valid data
	case ${TMP_ENGNUM} in
		3000) ;; # valid value; WE65ac KidsWifi v3
		100) ;; # valid value; WE65ac SmartOS/Lite
		*) return 1 ;; # disallow everything else
	esac

	# got a valid engnum
	return 0
}


print_mfg_info()
{
	printf "\n\n"
	printf "Manufacturing Info\n"
	printf "------------------\n"
	printf "  %-24s %s\n" "Base MAC:" "${MFG_MAC}"
	printf "  %-24s %s\n" "Model:" "${MFG_MODEL}"
	printf "  %-24s %s\n" "Serial:" "${MFG_SERIAL}"
	printf "  %-24s %s\n" "Full Serial Number:" "${MFG_MODEL}-${MFG_SERIAL}"
	printf "  %-24s %s\n" "Hardware Revision:" "${MFG_HWREV}"
	printf "  %-24s %s\n" "WPS PIN:" "${MFG_WPS_PIN}"
	printf "  %-24s %s\n" "EngNum:" "${MFG_ENGNUM}"
}


write_mfg_info_to_file()
{
	printf "# Manufacturing Info\n" > $MFG_TMP_FILE
	printf "MFG_MAC=${MFG_MAC}\n" >> $MFG_TMP_FILE
	printf "MFG_SERIAL=${MFG_SERIAL}\n" >> $MFG_TMP_FILE
	printf "MFG_MODEL=${MFG_MODEL}\n" >> $MFG_TMP_FILE
	printf "MFG_HWREV=${MFG_HWREV}\n" >> $MFG_TMP_FILE
	printf "MFG_WPS_PIN=${MFG_WPS_PIN}\n" >> $MFG_TMP_FILE
	printf "MFG_ENGNUM=${MFG_ENGNUM}\n" >> $MFG_TMP_FILE
	printf "\n" >> $MFG_TMP_FILE
}


write_mfg_info_to_flash()
{
	# Erase mfginfo partition
	printf "Erasing manufacturing flash partition ${MFG_PART}.. "

	mtd -q erase ${MFG_PART} 2>>/dev/null
	ret=$?

	if [ $ret -eq 0 ]; then
		printf "Success!\n"
	elif [ $ret -ne 0 ]; then
		printf "Failed, cause: %d\n" "$ret"
		printf "Device serialization failed, please report to SmartRG!\n"

		return 1
	fi


	# Write new data to mfginfo partitin
	printf "Writing manufacturing data to flash partition ${MFG_PART}.. "

	dd if=${MFG_TMP_FILE} of=${MFG_PART} 2>>/dev/null
	ret=$?

	if [ $ret -eq 0 ]; then
		printf "Success!\n"
		return 0
	else
		printf "Failed, cause: %d\n" "$ret"
		printf "Device serialization failed, please report to SmartRG!\n"

		return 1
	fi
}

# Restore to factory default 
factory_restore()
{
	# Erase factory partition so MACs get re-written at next boot
	get_factory_partition

	printf "Erasing factory flash partition ${FACTORY_PART}.. "

	mtd -q erase ${FACTORY_PART} 2>>/dev/null
	ret=$?

	if [ $ret -eq 0 ]; then
		return 0

	elif [ $ret -ne 0 ]; then
		printf "Failed, cause: %d\n" "$ret"
		printf "Device serialization failed, please report to SmartRG!\n"

		return 1
	fi

	# erase overlay
	/sbin/jffs2reset -y

	printf "\n"

	# sync and pause before returning and exiting
	sync
	sleep 1
	sync
}




#########
# Begin
#########
MODEL=""
PRODUCT="UNK"

TMP_MAC=""
TMP_SN=""
TMP_MODEL=""
TMP_SERIAL=""
TMP_HWREV=""
TMP_ENGNUM=""

MFG_MAC=""
MFG_MODEL=""
MFG_SERIAL=""
MFG_HWREV=""
MFG_ENGNUM=""
MFG_WPS_PIN=""

MFG_PART=""
MFG_PART_NAME="mfginfo"
MFG_TMP_FILE="/tmp/serialize.mfginfo.txt"

FACTORY_PART=""
FACTORY_PART_NAME="factory"

NEED_REEBOOT=0

##
# sample MAC: aabbccddeeff | aa:bb:cc:dd:ee:ff | AA:BB:CC:DD:EE:FF
# sample Serial: WE65ACA076-5002876
# sample HW Rev: A0
# sample HW EngNum: 3000
##

# install our sig handler
trap sig_handler SIGHUP SIGINT SIGTERM

# get hardware info
get_hw_info


# setup terminal - map erase to delete key
STTY_CFG=$(stty -g)
stty erase ^?

##
# 1980 called, they want their mainframe back
##
printf "######################################\n"
printf "#                                    #\n"
printf "#    ENTERING MANUFACTURING SHELL    #\n"
printf "#                                    #\n"
printf "#    Product: $PRODUCT                 #\n"
printf "#                                    #\n"
printf "######################################\n\n" 

##

# Get the mfg info if they are in mfg partition
if [ -e /tmp/mfginfo.sh ]; then
	source /tmp/mfginfo.sh
fi

SUCCESS="~!success!~"
FAILED="~!failed!~"
BUT_SUCCESS="~!success:"

# find mfg info partition
get_mfg_partition

##
# Build the WPS PIN
##
MFG_WPS_PIN=$(cat /dev/urandom 2>>/dev/null | tr -cd 0-9 2>>/dev/null | head -c 8)

fun_led()
{
	CMD_PATH="/usr/bin"
	PSID=`/bin/ps | $CMD_PATH/grep kiwi-leds | $CMD_PATH/grep -v grep | $CMD_PATH/awk '{print $1}'`
	
	if [ "$PSID" != "" ]; then
		/bin/kill -9 $PSID
	fi

	opt=$1
	led_name="/sys/class/leds/we65ac:range:"

# turn off all LEDs
	if [ "$opt" == "off" ]; then
		echo none > "$led_name"01-too-far/trigger
		echo none > "$led_name"02-too-far/trigger
		echo none > "$led_name"03-ok/trigger
		echo none > "$led_name"04-too-close/trigger
		echo none > "$led_name"05-too-close/trigger

		echo 0 > "$led_name"01-too-far/brightness
		echo 0 > "$led_name"02-too-far/brightness
		echo 0 > "$led_name"03-ok/brightness
		echo 0 > "$led_name"04-too-close/brightness
		echo 0 > "$led_name"05-too-close/brightness

# turn on all LED
	elif [ "$opt" == "on" ]; then
		echo default-on > "$led_name"01-too-far/trigger
		echo default-on > "$led_name"02-too-far/trigger
		echo default-on > "$led_name"03-ok/trigger
		echo default-on > "$led_name"04-too-close/trigger
		echo default-on > "$led_name"05-too-close/trigger
	else
		echo "$FAILED -invalid option"
		return 1
	fi	
	echo "$SUCCESS"
}

fun_button()
{
	opt=$1

	BTN_PATH="/etc/rc.button"
	TEST_PATH="/usr/srg/scripts"

	if [ "$opt" == "ban" ]; then
		/bin/cp -f $TEST_PATH/reset $BTN_PATH/reset
		/bin/cp -f $TEST_PATH/BTN_0 $BTN_PATH/BTN_0
		/bin/cp -f $TEST_PATH/BTN_2 $BTN_PATH/BTN_2

		echo "$SUCCESS"

	elif [ "$opt" == "resume" ]; then
		/bin/cp -f /rom$BTN_PATH/reset $BTN_PATH/reset
		/bin/cp -f /rom$BTN_PATH/BTN_0 $BTN_PATH/BTN_0
		/bin/cp -f /rom$BTN_PATH/BTN_2 $BTN_PATH/BTN_2

		echo "$SUCCESS"

	elif [ "$opt" == "r" ]; then
		/bin/cp -f $TEST_PATH/reset $BTN_PATH/reset
		/bin/cp -f $TEST_PATH/BTN_0 $BTN_PATH/BTN_0
		/bin/cp -f $TEST_PATH/BTN_2 $BTN_PATH/BTN_2

		COUNTER=0
		PLAG_PATH="/tmp/button_flag"

		while [ $COUNTER -lt 9 ]; do
#			echo the counter is $COUNTER
			let COUNTER=COUNTER+1
			/bin/sleep 1

			var=""
			if [ -f $PLAG_PATH/reset ]; then
				var="reset"
			elif [ -f $PLAG_PATH/wps ]; then 
				var="wps"
			elif [ -f $PLAG_PATH/unlock ]; then 
				var="unlock"
			elif [ -f $PLAG_PATH/lock ]; then 
				var="lock"
			fi

#			echo $var
			if [ "$var" != "" ]; then
				echo $BUT_SUCCESS$var"!~"
				/bin/rm -rf $PLAG_PATH
				return 1
			fi

			if [ $COUNTER -ge 9 ]; then
				echo "$FAILED"
			fi			
		done
	else 
		echo "$FAILED -invalid option"
	fi

}

fun_cmd_list()
{
	echo "mfg-set mac xx:xx:xx:xx:xx:xx"
	echo "mfg-set sn <value>"
	echo "mfg-set hwrev <value>"
	echo "mfg-set engnum <value>"

	echo "mfg-get mac"
	echo "mfg-get sn"
	echo "mfg-get hwrev"
	echo "mfg-get engnum"

	echo "mfg-cmd led [on/off]"
	echo "mfg-cmd button [ban/resume/r]"
	echo "mfg-cmd mfgblock"
	echo "mfg-cmd mfglist"
	echo "mfg-cmd restore"
}

fun_mfg_get()
{
	opt=$1

	if [ "$opt" == "mac" ]; then
		echo ~!"${MFG_MAC}"!~

 	elif [ "$opt" == "sn" ]; then
		echo ~!"${MFG_MODEL}-${MFG_SERIAL}"!~

	elif [ "$opt" == "hwrev" ]; then
		echo ~!"${MFG_HWREV}"!~

	elif [ "$opt" == "engnum" ]; then
		echo ~!"${MFG_ENGNUM}"!~

	else
		echo "failed -invalid option"
	fi
}

fun_mfg_set()
{
	opt=$1

	if [ "$opt" == "mac" ]; then
		TMP_MAC=$2
	
		verify_mac
		if [ $? -eq 0 ]; then
			MFG_MAC=$TMP_MAC
			echo "$SUCCESS"
		else
			echo "$FAILED"
		fi

	elif [ "$opt" == "sn" ]; then
		TMP_SN=$2
	
		verify_serial
		if [ $? -eq 0 ]; then
			MFG_SERIAL=$TMP_SERIAL
			MFG_MODEL=$TMP_MODEL
			echo "$SUCCESS"
		else
			echo "$FAILED"
		fi

	elif [ "$opt" == "hwrev" ]; then
		TMP_HWREV=$2
	
		verify_hw_rev
		if [ $? -eq 0 ]; then
			MFG_HWREV=$TMP_HWREV
			echo "$SUCCESS"
		else
			echo "$FAILED"
		fi

	elif [ "$opt" == "engnum" ]; then
		TMP_ENGNUM=$2

		verify_hw_engnum
		if [ $? -eq 0 ]; then
			MFG_ENGNUM=$TMP_ENGNUM
			echo "$SUCCESS"
		else
			echo "$FAILED"
		fi

	else
		echo "failed -invalid option"
	fi
}


fun_mfg_cmd()
{
	opt=$1

	if [ "$opt" == "led" ]; then
		fun_led $2;
	elif [ "$opt" == "button" ]; then
		fun_button $2;
	elif [ "$opt" == "mfgblock" ]; then
		write_mfg_info_to_file
		write_mfg_info_to_flash

		if [ $? -eq 0 ]; then
			echo "$SUCCESS"
		else
			echo "$FAILED"
		fi

 	elif [ "$opt" == "restore" ]; then
		factory_restore

		if [ $? -eq 0 ]; then
			echo "$SUCCESS"
		else
			echo "$FAILED"
		fi

	elif [ "$opt" == "mfglist" ]; then
		print_mfg_info

	else
		echo "failed -invalid option"
	fi
}


while true; do

	read -p "#" CMD OPT P1 P2 P3

	if [ "$CMD" == "help" ]; then
		fun_cmd_list;

 	elif [ "$CMD" == "mfg-set" ]; then
		fun_mfg_set $OPT $P1;

	elif [ "$CMD" == "mfg-get" ]; then
		fun_mfg_get $OPT;

	elif [ "$CMD" == "mfg-cmd" ]; then
		fun_mfg_cmd $OPT $P1;

	else
		echo "failed: -invalid command"
	fi	
done


##
# Exit cleanly
##
do_exit 0

