#!/bin/sh
###############################################################################
#               _____                      _  ______ _____                    #
#              /  ___|                    | | | ___ \  __ \                   #
#              \ `--. _ __ ___   __ _ _ __| |_| |_/ / |  \/                   #
#               `--. \ '_ ` _ \ / _` | '__| __|    /| | __                    #
#              /\__/ / | | | | | (_| | |  | |_| |\ \| |_\ \                   #
#              \____/|_| |_| |_|\__,_|_|   \__\_| \_|\____/ Inc.              #
#                                                                             #
###############################################################################
#                                                                             #
#                       copyright 2016 by SmartRG, Inc.                       #
#                              Santa Barbara, CA                              #
#                                                                             #
###############################################################################
#                                                                             #
# Author: Chad Monroe                                                         #
#                                                                             #
# Purpose: Shell for telnet to call during initial device serialization       #
#                                                                             #
###############################################################################
. /lib/ramips.sh


do_exit()
{
	# Restore terminal settings to whatever they were
	stty ${STTY_CFG}

	# Notify user we are closing down
	printf "\nSerialization process finished, disconnecting.. \n\n"
	sleep 1

	exit $1
}


sig_handler() 
{
	# do any cleanup and bail
	printf "\n\ncaught signal, exiting..\n"

	do_exit 1
}


get_hw_info()
{
	if [ -f "/tmp/sysinfo/model" ]; then
		MODEL=$(cat /tmp/sysinfo/model 2>>/dev/null)
	fi

	if [ -n "$MODEL" ]; then
		PRODUCT="$MODEL"
	else
		PRODUCT=$(ramips_board_name)
	fi
}


get_factory_partition()
{
	FACTORY_PART=$(cat /proc/mtd | grep "${FACTORY_PART_NAME}" | cut -d: -f1)

	if [ -z "$FACTORY_PART" ]; then
		printf "ERROR: no MTD device for factory partition found!"

		do_exit 1
	else
		FACTORY_PART=$(printf "/dev/${FACTORY_PART}")
	fi

	printf "Factory partition ${FACTORY_PART_NAME} found at ${FACTORY_PART}\n\n"
}


get_mfg_partition()
{
	MFG_PART=$(cat /proc/mtd | grep "${MFG_PART_NAME}" | cut -d: -f1)

	if [ -z "$MFG_PART" ]; then
		printf "ERROR: no MTD device for manufacturing partition found!"

		do_exit 1
	else
		MFG_PART=$(printf "/dev/${MFG_PART}")
	fi

	printf "Manufacturing partition ${MFG_PART_NAME} found at ${MFG_PART}\n\n"
}


mac_fixup()
{
	SPLIT=${TMP_MAC:0:2}
	for i in 2 4 6 8 10; do
		SPLIT=${SPLIT}:${TMP_MAC:${i}:2}
	done

	TMP_MAC=$(echo $SPLIT)
}


verify_mac()
{
	local search

	# trim and capitalize                                 
	TMP_MAC=$(printf ${TMP_MAC} | awk '{print toupper($0)}')

	# check for invalid characters (not : or hex)
	TMP_MAC=$(printf "$TMP_MAC" | grep -E "^([a-fA-F0-9:]+)$")
	if [ ${#TMP_MAC} -le 0 ]; then
		return 1
	fi

	# if entered without seperators (e.g. via barcode
	# reader) then add in seperators if value is valid
	search=$(printf "$TMP_MAC" | grep ':')
	if [ -z "$search" ]; then
		if [ ${#TMP_MAC} -eq 12 ]; then
			mac_fixup
		else
			printf "\ERROR: no seperators found in MAC and size incorrect\n"
			return 1
		fi
	fi

	# make sure it's formatted as we are expecting and 17 chars long
	TMP_MAC=$(printf "$TMP_MAC" | grep -E "^([0-9A-Fa-f]{2})((:[0-9A-Fa-f]{2}){5})$")
	if [ ${#TMP_MAC} -ne 17 ]; then                     
		return 1                              
	fi  

	# got a good MAC
	return 0
}


verify_serial()
{
	# trim and capitalize                                    
	TMP_SN=$(printf ${TMP_SN} | awk '{print toupper($0)}')

	# split SN into model
	TMP_MODEL=$(printf "$TMP_SN" | cut -d- -f1)
	if [ ${#TMP_MODEL} -le 0 ]; then
		return 1
	fi

	# check for valid data and length
	TMP_MODEL=$(printf "$TMP_MODEL" | grep -E "^([a-zA-Z0-9]{10})$")
	if [ ${#TMP_MODEL} -ne 10 ]; then
		return 1
	fi

	# split SN into serial
	TMP_SERIAL=$(printf "$TMP_SN" | cut -d- -f2)
	if [ ${#TMP_SERIAL} -le 0 ]; then
		return 1
	fi

	# check for valid data and length
	TMP_SERIAL=$(printf "$TMP_SERIAL" | grep -E "^([0-9]{7})$")
	if [ ${#TMP_SERIAL} -ne 7 ]; then
		return 1
	fi

	# got a good model + S/N
	return 0
}


verify_hw_rev()
{
	# trim and capitalize                                    
	TMP_HWREV=$(printf ${TMP_HWREV} | awk '{print toupper($0)}')

	# check for valid data and length
	TMP_HWREV=$(printf "$TMP_HWREV" | grep -E "^([a-zA-Z0-9]{2})$")
	if [ ${#TMP_HWREV} -ne 2 ]; then
		return 1
	fi


	# not much else we can do here.. looks good
	return 0
}


verify_hw_engnum()
{
	# trim string
	TMP_ENGNUM=$(printf ${TMP_ENGNUM})

	# check for valid data
	case ${TMP_ENGNUM} in
		3000) ;; # valid value; WE65ac KidsWifi v3
		100) ;; # valid value; WE65ac SmartOS/Lite
		*) return 1 ;; # disallow everything else
	esac

	# got a valid engnum
	return 0
}


print_mfg_info()
{
	printf "\n\n"
	printf "Manufacturing Info\n"
	printf "------------------\n"
	printf "  %-24s %s\n" "Base MAC:" "${MFG_MAC}"
	printf "  %-24s %s\n" "Model:" "${MFG_MODEL}"
	printf "  %-24s %s\n" "Serial:" "${MFG_SERIAL}"
	printf "  %-24s %s\n" "Full Serial Number:" "${MFG_MODEL}-${MFG_SERIAL}"
	printf "  %-24s %s\n" "Hardware Revision:" "${MFG_HWREV}"
	printf "  %-24s %s\n" "WPS PIN:" "${MFG_WPS_PIN}"
	printf "  %-24s %s\n" "EngNum:" "${MFG_ENGNUM}"
}


write_mfg_info_to_file()
{
	printf "# Manufacturing Info\n" > $MFG_TMP_FILE
	printf "MFG_MAC=${MFG_MAC}\n" >> $MFG_TMP_FILE
	printf "MFG_SERIAL=${MFG_SERIAL}\n" >> $MFG_TMP_FILE
	printf "MFG_MODEL=${MFG_MODEL}\n" >> $MFG_TMP_FILE
	printf "MFG_HWREV=${MFG_HWREV}\n" >> $MFG_TMP_FILE
	printf "MFG_WPS_PIN=${MFG_WPS_PIN}\n" >> $MFG_TMP_FILE
	printf "MFG_ENGNUM=${MFG_ENGNUM}\n" >> $MFG_TMP_FILE
	printf "\n" >> $MFG_TMP_FILE
}


write_mfg_info_to_flash()
{
	# Erase mfginfo partition
	printf "Erasing manufacturing flash partition ${MFG_PART}.. "

	mtd -q erase ${MFG_PART} 2>>/dev/null
	ret=$?

	if [ $ret -eq 0 ]; then
		printf "Success!\n"
	elif [ $ret -ne 0 ]; then
		printf "Failed, cause: %d\n" "$ret"
		printf "Device serialization failed, please report to SmartRG!\n"

		return 1
	fi


	# Write new data to mfginfo partitin
	printf "Writing manufacturing data to flash partition ${MFG_PART}.. "

	dd if=${MFG_TMP_FILE} of=${MFG_PART} 2>>/dev/null
	ret=$?

	if [ $ret -eq 0 ]; then
		printf "Success!\n"
	else
		printf "Failed, cause: %d\n" "$ret"
		printf "Device serialization failed, please report to SmartRG!\n"

		return 1
	fi

	# Erase factory partition so MACs get re-written at next boot
	get_factory_partition

	printf "Erasing factory flash partition ${FACTORY_PART}.. "

	mtd -q erase ${FACTORY_PART} 2>>/dev/null
	ret=$?

	if [ $ret -eq 0 ]; then
		printf "Success!\n"
	elif [ $ret -ne 0 ]; then
		printf "Failed, cause: %d\n" "$ret"
		printf "Device serialization failed, please report to SmartRG!\n"

		return 1
	fi

	# erase overlay
	/sbin/jffs2reset -y

	printf "\nDevice serialization complete, rebooting.. \n"
	
	# sync and pause before returning and exiting
	sync
	sleep 1
	sync
}




#########
# Begin
#########
MODEL=""
PRODUCT="UNK"

TMP_MAC=""
TMP_SN=""
TMP_MODEL=""
TMP_SERIAL=""
TMP_HWREV=""
TMP_ENGNUM=""

MFG_MAC=""
MFG_MODEL=""
MFG_SERIAL=""
MFG_HWREV=""
MFG_ENGNUM=""
MFG_WPS_PIN=""

MFG_PART=""
MFG_PART_NAME="mfginfo"
MFG_TMP_FILE="/tmp/serialize.mfginfo.txt"

FACTORY_PART=""
FACTORY_PART_NAME="factory"

NEED_REEBOOT=0

##
# sample MAC: aabbccddeeff | aa:bb:cc:dd:ee:ff | AA:BB:CC:DD:EE:FF
# sample Serial: WE65ACA076-5002876
# sample HW Rev: A0
# sample HW EngNum: 3000
##

# install our sig handler
trap sig_handler SIGHUP SIGINT SIGTERM

# get hardware info
get_hw_info


# setup terminal - map erase to delete key
STTY_CFG=$(stty -g)
stty erase ^?

##
# 1980 called, they want their mainframe back
##
printf "######################################\n"
printf "#                                    #\n"
printf "#    ENTERING MANUFACTURING SHELL    #\n"
printf "#                                    #\n"
printf "#    Product: $PRODUCT                 #\n"
printf "#                                    #\n"
printf "######################################\n\n" 

# find mfg info partition
get_mfg_partition


##
# Get the base MAC
##
printf "Enter Base MAC Address: "
while [ 1 ]; do
	read TMP_MAC
	
	verify_mac
	if [ $? -eq 0 ]; then
		MFG_MAC=$TMP_MAC
		break
	else
		printf "Invalid base MAC syntax; please try again\n\n"
		printf "Enter Base MAC: "
	fi
done


##
# Get the serial number
##
printf "Enter Serial Number: "
while [ 1 ]; do
	read TMP_SN
	
	verify_serial
	if [ $? -eq 0 ]; then
		MFG_SERIAL=$TMP_SERIAL
		MFG_MODEL=$TMP_MODEL
		break
	else
		printf "Invalid serial number syntax; please try again\n\n"
		printf "Enter Serial Number: "
	fi
done


##
# Get the hardware rev
##
printf "Enter Hardware Revision: "
while [ 1 ]; do
	read TMP_HWREV
	
	verify_hw_rev
	if [ $? -eq 0 ]; then
		MFG_HWREV=$TMP_HWREV
		break
	else
		printf "Invalid hardware revision syntax; please try again\n\n"
		printf "Enter Hardware Revision: "
	fi
done


##
# Get the engnum
##
printf "Enter Hardware EngNum: "
while [ 1 ]; do
	read TMP_ENGNUM
	
	verify_hw_engnum
	if [ $? -eq 0 ]; then
		MFG_ENGNUM=$TMP_ENGNUM
		break
	else
		printf "Invalid hardware EngNum; please try again\n\n"
		printf "Enter Hardware EngNum: "
	fi
done


##
# Build the WPS PIN
##
MFG_WPS_PIN=$(cat /dev/urandom 2>>/dev/null | tr -cd 0-9 2>>/dev/null | head -c 8)


##
# Print data and verify with user
##
print_mfg_info

printf "\nWrite data to flash? (y/n) "
read DOIT

case ${DOIT} in
	[Yy]*) write_mfg_info_to_file && write_mfg_info_to_flash && NEED_REEBOOT=1 ;;
	*) printf "\nSerialization aborted by user; flash NOT written!\n\n" ;;
esac


##
# Verify reboot with the user if needed
##
printf "\nPerform reboot to complete changes? (y/n) "
read DOIT

case ${DOIT} in
	[Yy]*) printf "\n\nRebooting NOW!!\n\n"; sleep 1; reboot ;;
	*) printf "\nNot rebooting per user request\n" ;;
esac


##
# Exit cleanly
##
do_exit 0

